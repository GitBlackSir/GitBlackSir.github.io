---
layout: post
title: LeetCode-树
category: LeetCode
---
---

##### 树定义

```
struct TreeNode {
     int val;
     TreeNode *left;
     TreeNode *right;
     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

##### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

- 1.递归查找子树是否符合 BST 的定义
- 2.利用搜索树的定义自上而下去做，因为有序，所以每个节点值有确定的范围

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return dfs(root, INT_MIN, INT_MAX);
    }
    
    bool dfs(TreeNode* root, long long min, long long max) {
        if (!root) 
          return true;        
        if (root->val < min || root->val > max) 
          return false;
        
        return dfs(root->left, min, root->val - 1ll) && dfs(root->right, root->val + 1ll, max);
    }
};
```

##### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

- 1.用栈模拟递归栈 🐼

```c++
class Solution {
public:
    vector<int> ans;
    stack<TreeNode*> s;
    vector<int> inorderTraversal(TreeNode* root) {
        // dfs(root);
        // return ans;
        auto node = root;
        while (node || !s.empty()) {
            while (node) {
                s.push(node);
                node = node->left;
            }
            node = s.top(); s.pop();
            ans.push_back(node->val);
            node = node->right;
        }
        return ans;
    }
    // void dfs(TreeNode* root) {
    //     if (!root) return;
    //     dfs(root->left);
    //     ans.push_back(root->val);
    //     dfs(root->right);
    // }
};
```

#####  [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

- 1.栈迭代
- 2.左子树左中右遍历，右子树右中左遍历
- 3.注意有无多余节点，退栈时值不等那么就不对称

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        stack<TreeNode*> left, right;
        auto l = root->left, r = root->right;
        while (l || r || !left.empty() || !right.empty()) {
            while (l && r) {
                left.push(l), l = l->left;
                right.push(r), r= r->right;
            }
            if (l || r) return false;
            l = left.top(), left.pop();
            r = right.top(), right.pop();
            if (l->val != r->val) return false;
            
            l = l->right, r= r->left;
        }
        return true;
    }
};
```
- 1.递归
- 2.自上而下比较值是否相同
- 3.注意递归终止条件 比较秀，只要有一方节点为空了，那么判断两方节点是否都为空，除此之外的情况就不对称了

```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        return dfs(root->left, root->right);
    }
    
    bool dfs(TreeNode* l, TreeNode* r) {
        if (!l || !r) return !l && !r;
        return l->val == r->val && dfs(l->left, r->right) && dfs(l->right, r->left);
    }
};
```

##### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

- 用队列模拟
- 代码中循环当前层的节点数次，目的是看当前循环的节点有无左右子节点
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if (!root) return {};
        vector<vector<int>> ans;
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int len = q.size();
            vector<int> level;
            while (len--) {
                auto node = q.front(); q.pop();
                level.push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            ans.push_back(level); 
        }
        return ans;
    }
};
```

##### [面试题26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

- 1.递归前序遍历实现
- 2.遍历A树，若找到A子结点 == B根结点，那么再判断当前两颗树结点是否重合

```c++
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (!A || !B) return false;
        if (A->val == B->val)
            if (dfs(A, B)) return true;
        return isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
    
    bool dfs(TreeNode* A, TreeNode* B) {
        if (!B) return true;
        else if (!A && B) return false;
        else if (A->val != B->val) return false;
        return dfs(A->left, B->left) && dfs(A->right, B->right);
    }  
};
```


##### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

##### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

##### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

##### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

##### [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

##### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)