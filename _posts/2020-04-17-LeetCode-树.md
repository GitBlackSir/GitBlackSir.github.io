---
layout: post
title: LeetCode-æ ‘
category: LeetCode
---
---

##### æ ‘å®šä¹‰

```
struct TreeNode {
     int val;
     TreeNode *left;
     TreeNode *right;
     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

##### [98. éªŒè¯äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/validate-binary-search-tree/)

- 1.é€’å½’æŸ¥æ‰¾å­æ ‘æ˜¯å¦ç¬¦åˆ BST çš„å®šä¹‰
- 2.åˆ©ç”¨æœç´¢æ ‘çš„å®šä¹‰è‡ªä¸Šè€Œä¸‹å»åšï¼Œå› ä¸ºæœ‰åºï¼Œæ‰€ä»¥æ¯ä¸ªèŠ‚ç‚¹å€¼æœ‰ç¡®å®šçš„èŒƒå›´

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return dfs(root, INT_MIN, INT_MAX);
    }
    
    bool dfs(TreeNode* root, long long min, long long max) {
        if (!root) 
          return true;        
        if (root->val < min || root->val > max) 
          return false;
        
        return dfs(root->left, min, root->val - 1ll) && dfs(root->right, root->val + 1ll, max);
    }
};
```

##### [94. äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

- 1.ç”¨æ ˆæ¨¡æ‹Ÿé€’å½’æ ˆ ğŸ¼

```c++
class Solution {
public:
    vector<int> ans;
    stack<TreeNode*> s;
    vector<int> inorderTraversal(TreeNode* root) {
        // dfs(root);
        // return ans;
        auto node = root;
        while (node || !s.empty()) {
            while (node) {
                s.push(node);
                node = node->left;
            }
            node = s.top(); s.pop();
            ans.push_back(node->val);
            node = node->right;
        }
        return ans;
    }
    // void dfs(TreeNode* root) {
    //     if (!root) return;
    //     dfs(root->left);
    //     ans.push_back(root->val);
    //     dfs(root->right);
    // }
};
```

#####  [101. å¯¹ç§°äºŒå‰æ ‘](https://leetcode-cn.com/problems/symmetric-tree/)

- 1.æ ˆè¿­ä»£
- 2.å·¦å­æ ‘å·¦ä¸­å³éå†ï¼Œå³å­æ ‘å³ä¸­å·¦éå†
- 3.æ³¨æ„æœ‰æ— å¤šä½™èŠ‚ç‚¹ï¼Œé€€æ ˆæ—¶å€¼ä¸ç­‰é‚£ä¹ˆå°±ä¸å¯¹ç§°

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        stack<TreeNode*> left, right;
        auto l = root->left, r = root->right;
        while (l || r || !left.empty() || !right.empty()) {
            while (l && r) {
                left.push(l), l = l->left;
                right.push(r), r= r->right;
            }
            if (l || r) return false;
            l = left.top(), left.pop();
            r = right.top(), right.pop();
            if (l->val != r->val) return false;
            
            l = l->right, r= r->left;
        }
        return true;
    }
};
```
- 1.é€’å½’
- 2.è‡ªä¸Šè€Œä¸‹æ¯”è¾ƒå€¼æ˜¯å¦ç›¸åŒ
- 3.æ³¨æ„é€’å½’ç»ˆæ­¢æ¡ä»¶ æ¯”è¾ƒç§€ï¼Œåªè¦æœ‰ä¸€æ–¹èŠ‚ç‚¹ä¸ºç©ºäº†ï¼Œé‚£ä¹ˆåˆ¤æ–­ä¸¤æ–¹èŠ‚ç‚¹æ˜¯å¦éƒ½ä¸ºç©ºï¼Œé™¤æ­¤ä¹‹å¤–çš„æƒ…å†µå°±ä¸å¯¹ç§°äº†

```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        return dfs(root->left, root->right);
    }
    
    bool dfs(TreeNode* l, TreeNode* r) {
        if (!l || !r) return !l && !r;
        return l->val == r->val && dfs(l->left, r->right) && dfs(l->right, r->left);
    }
};
```

##### [102. äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

- ç”¨é˜Ÿåˆ—æ¨¡æ‹Ÿ
- ä»£ç ä¸­å¾ªç¯å½“å‰å±‚çš„èŠ‚ç‚¹æ•°æ¬¡ï¼Œç›®çš„æ˜¯çœ‹å½“å‰å¾ªç¯çš„èŠ‚ç‚¹æœ‰æ— å·¦å³å­èŠ‚ç‚¹
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if (!root) return {};
        vector<vector<int>> ans;
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int len = q.size();
            vector<int> level;
            while (len--) {
                auto node = q.front(); q.pop();
                level.push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            ans.push_back(level); 
        }
        return ans;
    }
};
```

##### [é¢è¯•é¢˜26. æ ‘çš„å­ç»“æ„](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

- 1.é€’å½’å‰åºéå†å®ç°
- 2.éå†Aæ ‘ï¼Œè‹¥æ‰¾åˆ°Aå­ç»“ç‚¹ == Bæ ¹ç»“ç‚¹ï¼Œé‚£ä¹ˆå†åˆ¤æ–­å½“å‰ä¸¤é¢—æ ‘ç»“ç‚¹æ˜¯å¦é‡åˆ

```c++
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (!A || !B) return false;
        if (A->val == B->val)
            if (dfs(A, B)) return true;
        return isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
    
    bool dfs(TreeNode* A, TreeNode* B) {
        if (!B) return true;
        else if (!A && B) return false;
        else if (A->val != B->val) return false;
        return dfs(A->left, B->left) && dfs(A->right, B->right);
    }  
};
```


##### [105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

##### [236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

##### [543. äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

##### [124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

##### [173. äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

##### [297. äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)