---
layout: post
title: LeetCode-贪心算法
category: LeetCode
---
---



##### [860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

- 1.柠檬水卖 5 元，若顾客掏出 20 元，我们尽量找他 10 + 5 元

```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int fives = 0, tens = 0;
        for(auto b : bills)
        {
            if(b == 5) fives++;
            else if(b == 10)
            {
                tens++;
                if(fives) fives--;
                else return false;
            }
            else
            {
                int t = 15;
                if(tens) { tens--; t -= 10; }
                while(fives && t) { fives--; t -= 5;}
                if(t) return false;
            }
        }
        return true;
    }
};
```

##### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

- 1.将孩子的胃口和饼干🍪的尺寸排序
- 2.找尽量小的饼干🍪来满足孩子的胃口

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        int j = 0;
            sort(g.begin(), g.end());
            sort(s.begin(), s.end());
            for(int i = 0; i < s.size() && j < g.size(); i++)
             if(s[i] >= g[j])
                 j++;
        return j;
    }
};
```



##### [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

- 1.遍历目标串
- 2.若子串匹配到目标串中相等字符，子串指针++

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int j = 0;
        for(int i = 0; i < t.size() && j < s.size(); i++)
            if(t[i] == s[j])
                j++;
        return j == s.size();
    }
};
```

##### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

- 1.将序列规整 保留相邻且重复的元素中的一个，并去除序列后边的元素
- 2.a b c 三个变量存储三个元素，判断此序列是以哪种摆动方式开头

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& f) {
        f.erase(unique(f.begin(), f.end()), f.end());
        if(f.size() <= 2) return f.size();
        int res = 2;
        for(int i = 1; i + 1 < f.size(); i++)
        {
            int a = f[i-1], b = f[i], c = f[i+1];
            if(a < b && b > c) res++;
            else if(a > b && b < c) res++;
        }
        return res;
    }
};
```



##### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

- 1.遍历并更新能跳到最远距离的 dist 变量

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int dist = 0;
        for(int i = 0; i < nums.size() && i <= dist; i++)
            dist = max(dist, nums[i] + i);
        return dist >= nums.size() - 1;
    }
};
```



##### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

- 1.找最小跳数
- 2.抽象成跳跃区间，找到所有能跳的区间即是最小跳数

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        if(nums.size() == 1) return 0;
        int l = 0, r = 0, step = 0;
        while(l <= r)
        {
            int max_r = 0;
            for(int i = l; i <= r; i++)
                max_r = max(max_r, i + nums[i]);
            
            step++;
            l = r + 1;
            r = max_r;
            if(max_r >= nums.size() - 1) break;
        }
        return step;
    }
};
```



##### [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

- 1.暴力做法 第一层 是`i++`
- 2.优化第一层循环为 `i += j +1` 若从 i 到 j 不能到达，那么 i - j 之间的点也不能到达 j ，因为 i 给之后的点留了遗产汽油都不能到达，所以再从 j + 1 点循环即可

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& g, vector<int>& c) {
        int n = g.size();
        for(int i = 0, j; i < n; i += j + 1)
        {
            int gas = 0;
            for(j = 0; j < n; j++)
            {
                int k = (i + j) % n;
                gas += g[k] - c[k];
                if(gas < 0)
                    break;
            }
            if(j == n)
                return i;
        }
        return -1;
    }
```



