---
layout: post
title: LeetCode-字符串
category: LeetCode
---
---

##### [38. 外观数列](https://leetcode-cn.com/problems/count-and-say/)

- 1.此题差评较多...
- 2.读懂题模拟就行，用`k`表示相邻的元素重复了几次（依题`1211` 读作`111221`）,那么`k`分别为`1`  `1`  `2`

```c++
class Solution {
    public:
    string countAndSay(int n) {
        string s = "1";
        for(int i = 0; i < n - 1; i++)
        {
            string temp;
            for(int j = 0; j < s.size(); )
            {
                int k = j;
                while(k < s.size() && s[k] == s[j]) k++;
                temp += to_string(k - j) + s[j];
                j = k;
            }
            s = temp;
        }
        return s;
    }
};
```



##### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

- 1.`Hash`表存字符串与字符串数组的映射
- 2.将遍历到的字符串排序后做`Key`，原字符串放入`Vector`

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        unordered_map<string, vector<string>> hash;
        for(auto s : strs)
        {
            string key = s;
            sort(key.begin(), key.end());
            hash[key].push_back(s);
        }
        for(auto it : hash) res.push_back(it.second);
        
        return res;
    }
};
```



##### [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

- 1.先翻转单词本身，再翻转整个字符串
- 2.注意过滤空格，并修改为我们想要的字符串类型

```c++
class Solution {
public:
    string reverseWords(string s) {
        int k = 0;
        for(int i = 0; i < s.size(); )
        {
            while(i < s.size() && s[i] == ' ') i++;
            if(i == s.size()) break;
            
            int j = i;
            while(j < s.size() && s[j] != ' ') j++;

            reverse(s.begin() + i, s.begin() + j);
            if(k) s[k++] = ' ';
            while(i < j) s[k++] = s[i++];
            
        }
        s.erase(s.begin() + k, s.end());
        reverse(s.begin(), s.end());
        return s;
    }
};
```



##### [557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

- 1.找到单个单词区间，翻转并更新遍历指针

```c++
class Solution {
public:
    string reverseWords(string s) {
        for(int i = 0; i < s.size(); )
        {
            int j = i;
            if(s[i] == ' ') j++;
            else
            {
                while(j < s.size() && s[j] != ' ') j++;
                reverse(s.begin() + i, s.begin() + j);
            }
            i = j;
        }
        return s;
    }
};
```



##### [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)

- 1.以`.`为分界比较每一段的版本号大小

```c++
class Solution {
public:
    int compareVersion(string s1, string s2) {
        int i = 0, j = 0;
        
        while(i < s1.size() || j < s2.size())
        {
            int x = i, y = j;
            while(x < s1.size() && s1[x] != '.') x++;
            while(y < s2.size() && s2[y] != '.') y++;
            int a = i == x ? 0 : atoi(s1.substr(i, x - i).c_str());
            int b = j == y ? 0 : atoi(s2.substr(j, y - j).c_str());
            if(a > b) return 1;
            if(a < b) return -1;
            i = x + 1;
            j = y + 1;
        }
        return 0;
    }
};
```



##### [929. 独特的电子邮件地址](https://leetcode-cn.com/problems/unique-email-addresses/)

- 1.`Set` 来存电邮地址
- 2.每个电邮分两段，第一段去`.`和`+`后边到`@`的串
- 3.第二段不用操作拼接即可

```c++
class Solution {
public:
    int numUniqueEmails(vector<string>& emails) {
        unordered_set<string> hash;
        for(auto s : emails)
        {
            int at = s.find('@');
            string name;
            for(auto c : s.substr(0, at))
            {
                if(c == '+') break;
                if(c != '.') name += c;
            }
            string domain = s.substr(at+1);
            hash.insert(name + '@' + domain);
        }
        return hash.size();
    }
};
```



##### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

- 1.枚举中心点，向左右两边扩散
- 2.注意回文串有奇偶串之分

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        string res;
        for(int i = 0; i < s.size(); i++)
        {
            for(int j = i, k = i; j >= 0 && k < s.size() && s[j] == s[k]; j--, k++)
                if(res.size() < (k - j + 1))
                    res = s.substr(j, k - j + 1);
            
            for(int j = i, k = i + 1; j >= 0 && k < s.size() && s[j] == s[k]; j--, k++)
                if(res.size() < (k - j + 1))
                    res = s.substr(j, k - j + 1);
        }
        return res;
    }
};
```



##### [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

- 1.画出 Z 字形，找其数组下标规律

```c++
class Solution {
public:
    string convert(string s, int n) {
        if(n == 1) return s;
        string res;
        for(int i = 0; i < n; i++)
        {
            if(!i || i == n - 1)
            {
                for(int j = i; j < s.size(); j += 2 * (n - 1)) res += s[j];
            }
            else
            {
                for(int j = i, k = 2 * (n - 1) - i; j < s.size() || k < s.size(); j +=  2 * (n - 1), k += 2 * (n - 1))
                {
                    if(j < s.size()) res += s[j];
                    if(k < s.size()) res += s[k];
                }
            }
        }
        return res;
    }
};
```



##### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

- 1.哈希表存贮字符和字符数量映射
- 2.`i` `j`指针都不回头，当`s[i]`字符重复时，`j`指针后移并找到重复的位置，并使重复的字符数量减一
- 3.每次更新无重复子串的长度

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> hash;
        int res = 0;
        for(int i = 0, j = 0; i < s.size(); i++)
        {
            hash[s[i]]++;
            while(hash[s[i]] > 1) hash[s[j++]]--;
            res = max(res, i - j + 1);
        }
        return res;
    }
};
```



##### [434. 字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)

- 1.单词中可能包含  `' ` ` - ` 等符号，尽可能过滤掉
- 2.遍历时 若指针前的值等于`' '`且当前指针的值不为`' '`的情况 单词数量加一

```c++
class Solution {
public:
    int countSegments(string s) {
        int res = 0;
        for(int i = 0; i < s.size(); i++)
            if( (i == 0 || s[i-1] == ' ') && s[i] != ' ')
                res++;
        return res;
    }
};
```
