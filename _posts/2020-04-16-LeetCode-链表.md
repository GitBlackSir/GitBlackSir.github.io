---
layout: post
title: LeetCode-链表
category: LeetCode
---
---

##### 链表定义

```
public class ListNode {
     int val;
     ListNode next;
     ListNode(int x) { val = x; }
}
```

##### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

- 1.建立 pre 节点 (记录 cur 左边的结点) 和 cur 节点
- 2.遍历并调整节点，因调整链表导致断链，用临时节点 next 记录 cur.next
- 3.返回pre节点

```
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

##### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

- 将 m-n 之间的指针翻转
- 和上题不同的是，此题需小心处理并记录好边界的值

```
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if(m == n) return head;
        var node = new ListNode(-1);
        node.next = head;
        var left = node;
        var right = node;
        
        for(int i = 0; i < m - 1; i++) left = left.next;
        for(int i = 0; i < n; i++) right = right.next;
        
        var leftTemp = left.next;
        var rightTemp = right.next;
        
        ListNode pre = null;
        var cur = leftTemp;
        while(cur != rightTemp){
            var next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        
        leftTemp.next = rightTemp;
        left.next = pre;
        return node.next;
    }
}
```


##### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

- 1.建立虚拟头结点
- 2.遍历临时 cur 结点
- 3.循环内部建立 left right 指针
- 4.调整结点顺序最后移动 cur 结点
- 5.返回虚节点的下一节点

```
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode node = new ListNode(-1);
        node.next = head;
        
        for(var cur = node; cur.next != null && cur.next.next != null; ){
            var left = cur.next; var right = left.next;
            
            cur.next = right;
            left.next = right.next;
            right.next = left;
            
            cur = left;
        }
    return node.next;
    }
}
```

##### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

- 1.判断空节点
- 2.建立快慢指针
- 3.计算链表长度 len (有可能给的 k 很大，所以将  k %= len 来优化操作 )
- 4.快指针走 k 步
- 5.遍历快慢指针
- 6.调整节点并返回新的头结点

```
class Solution {
    private int len = 0;
    public ListNode rotateRight(ListNode head, int k) {
        if(head == null) return null;
        ListNode fir = head, sec = head;
        for(var i = head; i !=null; i = i.next) len++;
        
        k %= len;
        
        while(k-- > 0) fir = fir.next;
        
        while(fir.next != null){
            fir = fir.next;
            sec = sec.next;
        }
        
        fir.next = head;
        head = sec.next;
        sec.next = null;
        
        return head;
    }
}
```

##### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

题目只给了要删除节点的指针

- 1.将此节点的val修改为下一节点的val
- 2.删除下一个节点

```
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```


##### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

- 1.建立虚拟头结点
- 2.fir指针 先走 n 步
- 3.fir 和 sec 同时走，fir指针走道链表尾部结束
- 4.删除sec指针后的结点
- 5.返回虚拟头结点的下一结点

```
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode node = new ListNode(-1);
        node.next = head;
        
        ListNode fir = node;
        ListNode sec = node;
        
        while(n-- > 0) fir = fir.next;
        
        while(fir.next != null){
            fir = fir.next;
            sec = sec.next;
        }
        sec.next = sec.next.next;
        return node.next;    
    }
}
```


##### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

- 1.先用node记录头head头结点点
- 2.遍历head节点，遇到当前节点val等于下一节点val 就删除下一节点，否则移动head节点
- 3.返回node节点

```
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode node = head;
        while(head != null){
            if(head.next != null && head.val == head.next.val)
                head.next = head.next.next;
            else head = head.next;
        }
    return node;
    }
}
```


##### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

- 1.假设 headA 到相交点距离为 a，headB 到相交点距离为 b
- 2.假设相交点到链表尾部距离为 c
- 3.那么两个链表遍历 a + b + c 步他们一定相遇 ( 如果不想交 遍历最后也都为null )

```
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode n1 = headA, n2 = headB;
        while(n1 != n2){
            if(n1 == null) n1 = headB;
            else n1 = n1.next;
                
            if(n2 == null) n2 = headA;
            else n2 = n2.next;
        }
        return n1;
    }
}
```

##### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

[官网题解](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/)

- 1.先找快慢指针相交点
- 2.找到后将快指针指向头结点，不分快慢同时遍历找到切点
```
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(fast == slow){
                fast = head;
                while(fast != slow){
                    fast = fast.next;
                    slow = slow.next;
                }
                return fast;
            }
        }
        return null;
    }
}
```



##### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

- 1.自底向上归并，反之有递归栈不符合要求
- 2.明日再淦！
- 3.来了，Bottom-Up 归并链表太难写了，再修炼修炼，先用优先级队列

```
class Solution {
    public ListNode sortList(ListNode head) {
        Queue<Integer> q = new PriorityQueue<>();
        var cur = head;
        while(cur != null){
            q.add(cur.val);
            cur = cur.next;
        }
        cur = head;
        while(cur != null){
            cur.val = q.poll();
            cur = cur.next;
        }
        return head;
    }
}
```